Multi-Thread
현대 CPU는 다중 코어 CPU
단일 Thread로는 동시에 하나의 코어만 사용할 수 있다.
병렬화 가능한 작업을 Thread로 나누어 처리하면 놀고 있는 코어를 적극적으로 사용할 수 있다.
머신 성능을 최대한 사용 가능하게 하자! (CPU 점유율 100%를 향해..; 물론 이러면 다른 기능에 할당된 시간이 줄어들어서 다른 문제가 발생할 수 있다.)

Thread 활용 예시
- Case 1 [특정 작업 전담 thread]
   - Log Thread: File RW 작업은 느린 작업이다. 디스크는 Memory에 비해 느린 장치로, Main thread에서 처리했다면, 디스크에 Write를 하는 시간을 기다려야 한다. 하지만, 별도의 Thread에서 처리하도록 하면 RW작업을 별도의 thread에서 처리할 수 있다. 불필요하게 발생하는 대기시간을 줄일 수 있다.
      - 주요 기술
         - Multiple Producer Single Consumer Queue 와 같은 자료구조
            - 여러 Thread에서 Message를 던지면 Log thread에서 해당 데이터를 읽어서 처리
- Case 2 [Main 에서 Thread로 작업 요청 -> 끝나면 main으로 통보]
   - DB thread에 데이터 작성 요청
   - 작성 완료후 결과 main thread로 통보 (나중에 구현 예정)

- Case 3 [병렬화 가능한 작업 병렬 처리]
   - Main thread는 병렬화 가능한 작업이 끝나기 전까지 대기
   - 여러 thread를 만들거나 ThreadPool을 활용해서 병렬 연산을 처리한다 (async 등 활용)

공유 자원에 접근할때 경쟁 상태가 발생할 수 있다. (data race) 여러 thread가 공유 메모리에 동시에 값을 쓸때
 - 값을 메모리에서 레지스터에 불러온다, 레지스터 값을 변화시킨다, 레지스터 값을 메모리에 저장한다
와 같은 과정을 거치는데, 이때 발생할 수 있는 문제 글로 보여주기
이런 상황을 피하기 위해 락을 걸어서 락이 걸린 동안(언락을 하기 전까지)은 다른 thread가 해당 자원에 접근할 수 없다. (언락 될 떄 까지 기다리고 있는다)
일부 타입은 아토믹 연산이 되면 아토믹 변수로 락없이 사용 가능(동시에 접근 못하도록 하드웨어 명령어로 구현 또는 내부에서 락을 걸기도함)

기다리는 방식
- 스핀락 (for문 돌면서 락이 풀렸나 계속 확인) : 빠르게 락 언락 되는 환경에서 유용하다 (유저 영역에서 처리)
- 인터럽트 방식: OS에 끝나면 알려줘 라고 요청후 잠듬 (커널 영역까지 가야함) 락이 풀리면 OS가 해당 Thread를 깨움
- 혼용 방식: 일정 시간 스핀락을 시도하다가 인터럽트 방식으로 전환

데드락
- 락을 걸었는데 락을 건 thread에서 또 락을 걸어버림(탈출 조건이 없음. 락을 풀 수 없다! 관련 스레드가 멈춤)